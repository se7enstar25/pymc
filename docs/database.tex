

A typical MCMC run will generate thousands of samples, and some application requires well over 100000 iterations. Keeping all this information in memory can badly strain the performances of PyMC, and users will find their other applications slowing down. Moreover, we generally wish to store all or part of the sampled data for future use. However, there are dozens of different solutions to store data, and each user has his own preference based on previous experience, performance, compatibility, etc. To cover as many user cases as possible, PyMC proposes a database backend. That is, instead of hardcoding data management in the Sampler or Deterministic class, we ask that each stoch is provided with a set of methods taking care of tallying values, and eventually, returning them. PyMC provides a couple of backends for popular data management tools , but users have the possibility to code their own custom made backend, and let Sampler use it seamlessly.


%FIXME This table runs over the page.
\begin{longtable}[c]{|p{0.12\locallinewidth}|p{0.60\locallinewidth}|p{0.20\locallinewidth}|}
\caption{Description of database backends available in PyMC 2.0.}\\
\hline
\textbf{
Backend
} & \textbf{
Description
} & \textbf{
Dependencies
} \\
\hline
\endhead

no{\_}trace
 & 
Do not tally samples. Very efficient, mostly used
for testing purposes.
 & 
None
 \\
\hline

RAM
 & 
Store samples in memory. Efficient for small to
medium size samples.
 & 
None
 \\
\hline

pickle
 & 
Store samples in memory, then dump them in a
pickle file.
 & 
Cpickle
 \\
\hline

sqlite
 & 
Store samples in a sqlite database.
 & 
sqlite3
 \\
\hline

mysql
 & 
Store samples in a mysql database.
 & 
MySQLdb
 \\
\hline

txt
 & 
Store samples in memory, then dump them in a txt
file.
 & 
None
 \\
\hline

hdf5
 & 
Store samples in the HDF5 format.
 & 
pytables2.0
 \\
\hline
\end{longtable}

Backends are selected at Sampler instantiation through the db keyword:
\begin{quote}{\ttfamily \raggedright \noindent
S~=~Sampler(DisasterSampler,~db='sqlite')
}\end{quote}

Another possibility is to instantiate a Database, then pass it to Sampler:
\begin{quote}{\ttfamily \raggedright \noindent
DB~=~database.sqlite.Database(filename='test')~\\
S~=~Sampler(DisasterSampler,~db=DB)
}\end{quote}

This calling mechanism allows user to pass arguments to the Database, instead
of relying on the defaults. For databases that provide a load function, it also
allows user to open an existing database and restart interrupted computations:
\begin{quote}{\ttfamily \raggedright \noindent
DB~=~database.pickle.load('results.pickle')~\\
S~=~Sampler(DisasterSampler,~db=DB)
}\end{quote}


%___________________________________________________________________________

\hypertarget{use-of-trace-methods}{}
\pdfbookmark[0]{Use of trace methods}{use-of-trace-methods}
\section*{Use of trace methods}
\label{use-of-trace-methods}

From the user perpective, the only method that really matters is the gettrace()
method (equivalent to trace.{\_}{\_}call{\_}{\_}). This method returns the values tallied during sampling. So for
instance:
\begin{quote}{\ttfamily \raggedright \noindent
S~=~Sampler(DisasterModel,~db='ram')~\\
S.sample(30000,10000,2)
}\end{quote}

Will tally in memory every other sample, creating arrays of 15000 elements. To
fetch the last 10000 values of stoch \titlereference{e} say, we would type:
\begin{quote}{\ttfamily \raggedright \noindent
S.e.trace(burn=5000)
}\end{quote}


%___________________________________________________________________________

\hypertarget{backend-requirements}{}
\pdfbookmark[0]{Backend requirements}{backend-requirements}
\section*{Backend requirements}
\label{backend-requirements}

Each backend must define minimally two classes: Database and Trace. The Database
class is responsible for opening files, connecting to databases, assigning
tallyable nodes a Trace instance and calling its methods. Optionnaly,
the Database class can provide methods to save and return the state of the
sampler. This is useful for very long computations liable to be stopped then
restarted at a later time.
The Trace class defines several methods to tally and return the trace of nodes.

The basic framework of those classes is displayed in \href{PyMC2/database/base.py}{database/base.py}. Each
backend subclasses the base clases.

For more information about individual backends, refer to the \href{docs/API.pdf}{API} documentation.

\