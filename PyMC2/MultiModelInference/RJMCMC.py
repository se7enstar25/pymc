from PyMC2 import Parameter, Node, PyMCBase, SamplingMethod
from numpy import ma, random, where
from numpy.random import random
from copy import deepcopy

class OneAtATimeRJ(SamplingMethod):
    """
    S = OneAtATimeRJ(self, parameters, indicator, p, rp, g, q, rq, inv_q, Jacobian, **kwargs)
    
    OneAtATimeRJ can control single indicatored-array-valued parameters. The indicator
    indicates which parameters are currently 'in the model;' if 
    parameter.value.indicator[index] = True, that index is currently being excluded.
    
    indicatored-array-valued parameters and their children should understand how to
    cope with indicatored arrays when evaluating their logpabilities.
    
    The prior for the indicatored-array-valued parameter may depend explicitly on the
    indicator.
    
    The functional arguments are, in notation similar to that of Waagepetersen et al.,
    
        def rp(indicator):
            Draws a new value for the indicator.

        def p(indicator):
            Returns the probability of jumping to indicator.value from
            indicator.last_value inder rp.

        def rq(indicator):
            Draws a value for the auxiliary RV's u given indicator.value (proposed), 
            indicator.last_value (current), and the value of the parameters.

        def g(indicator, u, **parameters):
            g generates a new value for the parameters given indicator.last_value (current) and
            indicator.value (proposed), the current value of the parameter, and the auxiliary RV's 
            u which are generated by rq.
            
        def q(indicator, u):
            q computes the density of the auxiliary RV's u given the last_values of the parameters,
            and the current and proposed indicator values.
            
        def inv_q(indicator):
            inv_q computes the density, under the distribution defined by rq, of the value of u
            which would have been required to propose last_value of parameters from current_value.
    
        def Jacobian(indicator, u, **parameters):
            Returns the log Jacobian of the jump transformation (u,z) -> (u',z'), where u'
            is the value of the auxiliary RV u which would have been required to propose the
            current value z from the proposed value z_p.
            
        (u' is never used directly by this class, just implicitly in inv_q and Jacobian
        in case the transformation (z',z) -> u' isn't invertible. I think it's OK as far
        as math goes to use inverse images.)
    
    """
    def __init__(self, parameters, indicator, p, rp, g, q, rq, inv_q, Jacobian):
        
        SamplingMethod.__init__(self, pymc_objects = parameters)
        
        self.g = g
        self.q = q
        self.rq = rq
        self.p = p
        self.rp = rp
        self.inv_q = inv_q
        self.Jacobian = Jacobian
        
        self.parameter_dict = {}
        for parameter in parameters:
            self.parameter_dict[parameter.__name__] = parameter
        
        self.indicator = indicator
        

    def propose(self):
        """
        Sample a new indicator and value for the parameter.
        """
        self.rp(self.indicator)
        self._u = self.rq(self.indicator)               
        self.g(self.indicator, self._u, **self.parameter_dict)

                    
        
    def step(self):
        # logpability and loglike for parameter's current value:
        logp = sum([parameter.logp for parameter in self.parameters]) + self.indicator.logp
        loglike = self.loglike
        
        # Sample a candidate value for the value and indicator of the parameter.
        self.propose()

        # logpability and loglike for parameter's proposed value:
        logp_p = sum([parameter.logp for parameter in self.parameters]) + self.indicator.logp
        
        # Skip the rest if a bad value is proposed
        if logp_p == -Inf:
            for parameter in self.parameters: parameter.revert()
            return
        
        loglike_p = self.loglike
        
        # test:
        test_val =  logp_p + loglike_p - logp - loglike
        test_val += self.inv_q(self.indicator)
        test_val += self.q(self.indicator,self._u)

        if self.Jacobian is not None:
            test_val += self.Jacobian(self.indicator,self._u,**self.parameter_dict)

        if log(random()) > test_val:
            for parameter in self.parameters:
                parameter.revert


    def tune(self):
        pass



